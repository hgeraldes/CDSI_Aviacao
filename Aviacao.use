--------------------------------------------------------------
model Aviacao
--------------------------------------------------------------

class Main
	attributes
		hoje: CalendarDate
		amanha: CalendarDate
		depois: CalendarDate
		instant: Instant
		a: Aviao
		b: Aviao
		v1: Voo
		r1: Realizacao
		r2: Realizacao
		ISCTE: Empresa
		classeTuristica: Classe
		reservaISCTE: Reserva

	operations
	
		main()
			begin
				self.instant:= new Instant();
				
				self.teleprompter('-----------------------------------------------\n'
								+ '-- CENARIO DE GESTAO COMERCIAL\n'
								+ '-----------------------------------------------');
				
				self.teleprompter('Este cenario ocorre em tres datas.');
				self.scene1();				
				
				self.teleprompter('O voo TAP007 tera uma realizacao no dia de hoje,\n'
								+ 'usando o avião "Amalia", um Boeing 787.');
				self.scene2();

				self.teleprompter('Foi feita uma reserva de tres bilhetes em classe turistica \n'
								+ 'para tres investigadores do ISCTE para a realizacao de hoje do voo TAP007.');
				self.scene3();
				
				self.teleprompter('O voo TAP007 tera uma nova realizacao no dia de amanha,\n'
								+ 'usando o aviao "Eusebio", um Airbus A320.');
				self.scene4();
				
				self.teleprompter('A realizacao de hoje do voo TAP007 teve de ser cancelada porque o "Amalia" teve uma avaria.\n'
								+ 'Os bilhetes desta realizacao sao transferidos para a nova realizacao do voo TAP007 a decorrer amanha.');
				self.scene5();
				
				self.teleprompter('Telejornal abre com uma noticia surpresa:\n'
								+ 'os controladores de trafego aereo convocam uma greve para amanha,\n'
								+ 'pelo que a realizacao desse dia foi cancelada tambem.\n'
								+ 'Entretanto a avaria do "Amalia" foi consertada e os bilhetes sao transferidos\n'
								+ 'para uma nova realizacao do TAP007 a decorrer depois de amanha.');
				self.scene6();
				
				self.teleprompter('Outra noticia inesperada:\n'
								+ 'acaba de ocorrer um terrivel atentado bombista na cidade de destino do voo TAP007.\n'
								+ 'Como a reserva ainda estava pendente de pagamento, o ISCTE mandou cancelar a reserva\n'
								+ 'para nao por em risco a vida dos seus investigadores.');
				self.scene7();
			end
			
		teleprompter(message: String)
			begin
				for i in OrderedSet{1..30} do
					WriteLine('')
				end;
				WriteLine('*****************************************************************');
				WriteLine(message);
				WriteLine('*****************************************************************');
				WriteLine('\n\n\n' + 'Carregue em <Enter> para executar esta cena ...');
				ReadLine()
			end
			
		scene1()
			begin
				self.hoje := new CalendarDate();
				self.amanha := new CalendarDate();
				self.depois := new CalendarDate();
				self.hoje.init(3,5,2019);
				self.amanha.init(4,5,2019);
				self.depois.init(5,5,2019);
			end

		scene2()
			begin
				self.a := new Aviao();
				self.a.inicializa('Amalia', 'Boeing 787');
				self.v1 := new Voo();
				self.v1.numero := 'TAP007';
				self.r1:= self.v1.criarRealizacao(self.hoje, self.a)
			end
			
		scene3()
			begin
				self.ISCTE := new Empresa();
				self.ISCTE.inicializa(1234, 'ISCTE-IUL', 501510184, 'Av. das Forcas Armadas, Lx');

				--!reservaISCTE:= ISCTE.efetuarReserva(oclUndefined(CartaoCredito))
				self.reservaISCTE:= self.ISCTE.efetuarReserva(null);

				self.classeTuristica := new Classe(); 
				self.classeTuristica.tipo:= TipoClasse::TURISTICA;

				self.reservaISCTE.emitirBilhete(self.r1, 'Rui', 'Dias', self.classeTuristica, 54);
				self.reservaISCTE.emitirBilhete(self.r1, 'Rita', 'Peixoto', self.classeTuristica, 55);
				self.reservaISCTE.emitirBilhete(self.r1, 'Joao', 'Virtudes', self.classeTuristica, 56)
			end
			
		scene4()
			begin
				self.b := new Aviao();		
				self.b.inicializa('Eusebio', 'Airbus A320');
				self.r2:= self.v1.criarRealizacao(self.amanha, self.b)
			end
			
		scene5()
			begin
				self.v1.cancelarRealizacao(self.hoje, self.r2)
			end
			
		scene6()
			begin		
				self.v1.cancelarRealizacao2(self.amanha, self.depois, self.a)
			end
			
		scene7()
			begin
				self.ISCTE.desistirReserva(self.reservaISCTE, self.hoje)
			end		
				
	end	--Main

--------------------------------------------------------------
-- Domain types
--------------------------------------------------------------

enum EstadoPagamento {PENDENTE, EFETUADO}

enum TipoClasse {EXECUTIVA, NEGOCIO, TURISTICA}

enum Genero {MASCULINO, FEMININO}

--------------------------------------------------------------
-- BEGIN Custom Domain types
--------------------------------------------------------------
enum EstadoPista {ABERTA, FECHADA, ATERRAGEM, DESCOLAGEM}

enum EstadoTerminal {ABERTO, ENCERRADO}

enum EstadoPorta {ABERTA, FECHADA}

enum EstadoRevisao {PROGRAMADO, CONFIRMADO, EXECUCAO, CONCLUIDO}

enum TipoRecursoManutencao {TECNICO, MOTOR, PECA, CONSUMIVEL}

--------------------------------------------------------------
-- END Custom Domain types
--------------------------------------------------------------

-------------------------------------------------------------------------------------------------
--	Initial classes
-------------------------------------------------------------------------------------------------
class Voo
	attributes
		numero: String
		hora_partida: Instant
		hora_chegada: Instant
		milhas: Integer

	operations
		-- Inicialização de um voo
		inicializa(numero: String, hora_partida: Instant, hora_chegada: Instant, milhas: Integer, origem: Aeroporto, destino: Aeroporto)
			begin
				self.numero:= numero;
				self.hora_partida:= hora_partida;
				self.hora_chegada:= hora_chegada;
				self.milhas:= milhas;
				insert (origem, self) into Aeroporto_VoosPartida;
				insert (destino, self) into Aeroporto_VoosChegada
			end
			
		@OrigemDestinoDefinidos(rationale="Todos os voos têm uma origem e um destino!")
		pre OrigemDestinoDefinidos:
			origem.isDefined() and destino.isDefined()
			
		-- Ocupação média de um voo entre duas datas (resultado de operação)
		ocupacaoMedia(inicio: CalendarDate, fim: CalendarDate): Real =
			let realizacoes_voo:Set(Realizacao) = realizacao->reject(cancelada)->
				select(ocorre_em = inicio or ocorre_em = fim or ocorre_em.isAfter(inicio) and ocorre_em.isBefore(fim)) in
			realizacoes_voo.bilhetes->size() / realizacoes_voo.aviao.lotacao()->sum()
			
		-- Criar realização deste voo na data indicada, com o avião indicado
		criarRealizacao(data: CalendarDate, aviao: Aviao): Realizacao
			begin				
				result:= new Realizacao(self.numero+'_'+data.year.toString()+'_'+data.month.toString()+'_'+data.day.toString()) between (self, data);
				insert (aviao, result) into Aviao_Realizacao
			end
		
		@ParametrosInicializados(rationale="Tem de ser indicada uma data e um avião válidos!")
		pre ParametrosInicializados:
			data.isDefined() and aviao.isDefined()

		@RealizacaoNaoExiste(rationale="Não se pode criar uma realização se ela já existir!")
		pre RealizacaoNaoExiste:
			self.ocorre_em->excludes(data)
			
		@RealizacaoJaExiste(rationale="A realização foi criada com sucesso!")	
		post RealizacaoJaExiste:
			self.ocorre_em->includes(data) and self.realizacao->any(r | r.ocorre_em = data).aviao = aviao
			
		-- Apagar realização deste voo na data indicada		
		apagarRealizacao(data: CalendarDate)
			begin			
				destroy self.realizacao->any(r | r.ocorre_em = data)
			end
		
		@RealizacaoExiste(rationale="Tem de existir uma realização válida deste voo na data indicada!")
		pre RealizacaoExiste:
			data.isDefined() and self.ocorre_em->includes(data)

		@NaoHaBilhetesParaEssaRealizacao(rationale="Não se pode apagar uma realização quando já há bilhetes emitidos! Só se pode cancelar essa realização.")
		pre NaoHaBilhetesParaEssaRealizacao:
			self.realizacao->any(ocorre_em = data).bilhetes->isEmpty()
		
		@RealizacaoJaNaoExiste(rationale="A realização foi removida com sucesso!")
		post RealizacaoJaNaoExiste:
			self.ocorre_em->excludes(data)
			
		-- Cancelar realização deste voo na data antiga, transferindo os bilhetes para uma realização que é criada na nova data
		cancelarRealizacao2(dataAntiga: CalendarDate, dataNova: CalendarDate, aviaoNovo: Aviao)
		begin
			declare
					novaR: Realizacao;
					
			novaR:= self.criarRealizacao(dataNova, aviaoNovo);
			self.cancelarRealizacao(dataAntiga, novaR)
		end
		
		-- Cancelar realização deste voo na data indicada, transferindo os bilhetes para uma nova realização
		cancelarRealizacao(data: CalendarDate, novaRealizacao: Realizacao)
			begin
				declare
					r: Realizacao;
					
				r:= self.realizacao->any(r | r.ocorre_em = data);

				r.cancelada := true;

				for b in r.bilhetes do
					delete (r, b) from Realizacao_Bilhete;
					insert (novaRealizacao, b) into Realizacao_Bilhete
				end				
			end
		
		@RealizacaoExiste(rationale="Tem de existir uma realização válida deste voo na data indicada!")
		pre RealizacaoExiste:
			data.isDefined() and self.ocorre_em->includes(data)

		@RealizacaoNaoEstaCancelada(rationale="Não se pode cancelar uma realização quando esta já está cancelada!")
		pre RealizacaoNaoEstaCancelada:
			not self.realizacao->any(ocorre_em = data).cancelada
		
		@RealizacaoEstaCancelada(rationale="A realização foi cancelada com sucesso!")
		post RealizacaoEstaCancelada:
			self.realizacao->any(ocorre_em = data).cancelada and
			self.realizacao->any(ocorre_em = data).bilhetes->isEmpty() and
			novaRealizacao.bilhetes->includesAll(self.realizacao@pre->any(r | r.ocorre_em = data).bilhetes)
			
	constraints
	
		@UmVooNaoPodeOcorrerVariasVezesNoMesmoDia(rationale="um voo só se pode realizar uma vez para cada data.")
		inv UmVooNaoPodeOcorrerVariasVezesNoMesmoDia: 
			self.ocorre_em->isUnique(d | d.toString())

		@AeroportoChegadaDiferentePartida(rationale="Aeroporto de chegada diferente do de partida")
		inv AeroportoChegadaDiferentePartida:
			self.partida <> self.chegada
end

-------------------------------------------------------------------------------------------------	
class Aeroporto
	attributes
		nome: String

	operations
		-- 	Voos que partem deste aeroporto entre as horas indicadas
		voosPartidaEntre(horaInicial: Integer, horaFinal: Integer): OrderedSet(Voo) = voos_partida ->
			select(hora_partida.hours >= horaInicial and hora_partida.hours <= horaFinal)
		
		-- 	Voos que chegam a este aeroporto entre as horas indicadas
		voosChegadaEntre(horaInicial: Integer, horaFinal: Integer): OrderedSet(Voo) = voos_chegada ->
			select(hora_chegada.hours >= horaInicial and hora_chegada.hours <= horaFinal)
	
		-- A cidade mais próxima do aeroporto
		maisProxima(): Cidade = 
			let distanciaMaisProxima = self.proximidade.distancia->min in

			if self.servidas->isEmpty then
				oclUndefined(Cidade)
			else
				self.proximidade->any(distancia=distanciaMaisProxima).servidas
			endif
							
		-- Conjunto de todos os aviões que aterraram no aeroporto
		avioesQueAterraram(): Set(Aviao) = self.voos_chegada.realizacao->select(not cancelada).aviao->asSet
		
		-- Aeroporto em que há voos de chegada em mais datas diferentes
		calendarioMaisCoberto(): Aeroporto =
			let maisDatasChegada:Integer =			
				Aeroporto.allInstances->collect(voos_chegada.ocorre_em->asSet->size)->max
			in Aeroporto.allInstances->any(voos_chegada.ocorre_em->asSet->size = maisDatasChegada)
			
		-- Conjunto de datas em que ocorrem voos de partida ou de chegada no aeroporto
		datasComVoos(): Set(CalendarDate) =
			self.voos_partida->union(voos_chegada).ocorre_em->asSet

		-- Conjunto de datas em que ocorrem voos de partida ou de chegada no aeroporto		
		datasComVoos2(): Set(CalendarDate) =
			self.voos_partida.ocorre_em->union(voos_chegada.ocorre_em)->asSet			
			
	constraints
		
		@NaoHaCidadesMesmaDistancia(rationale="Não há mais do que uma cidade servida que fique à mesma distância do aeroporto")
		inv NaoHaCidadesMesmaDistancia:
			self.proximidade->isUnique(distancia)

		@VoosRealizadosComPartidaNaoCoincidente (rationale = "Não podem existir duas realizações de voos a partir à mesma hora no mesmo aeroporto")
		inv VoosRealizadosComPartidaNaoCoincidente: self.voos_partida.realizacao->
			forAll (r1, r2: Realizacao | r1 <> r2 and r1.ocorre_em.isEqual(r2.ocorre_em) implies 
				not r1.realiza_se.hora_partida.isEqual(r2.realiza_se.hora_partida))
		
		@VoosRealizadosComChegadaNaoCoincidente (rationale = "Não podem existir duas realizações de voos a chegar à mesma hora no mesmo aeroporto")
		inv VoosRealizadosComChegadaNaoCoincidente: self.voos_chegada.realizacao->
			forAll (r1, r2: Realizacao | r1 <> r2 and r1.ocorre_em.isEqual(r2.ocorre_em) implies 
				not r1.realiza_se.hora_chegada.isEqual(r2.realiza_se.hora_chegada))
end

-------------------------------------------------------------------------------------------------	
class Cidade
	attributes
		nome: String
		
	operations
	
		-- Voos de partida da cidade corrente
		voosPartida(): Sequence(Voo) = servem.voos_partida

		-- Voos de chegada da cidade corrente	
		voosChegada(): Sequence(Voo) = servem.voos_chegada
	
		-- O aeroporto mais próximo da cidade
		maisProximo(): Aeroporto = 
			let distanciaMaisProximo = self.proximidade.distancia->min in
			
			if self.servem->isEmpty then
				oclUndefined(Aeroporto)
			else
				self.proximidade->select(distancia=distanciaMaisProximo)->asOrderedSet->first.servem
			endif
		
	constraints
		
		@NaoHaAeroportosMesmaDistancia(rationale="Não há mais do que um aeroporto que fique à mesma distância da cidade")
		inv NaoHaAeroportosMesmaDistancia:
			self.proximidade->isUnique(distancia)
end

-------------------------------------------------------------------------------------------------	
class Pais
	attributes
		nome: String
		lingua: String
		moeda_oficial: String
		delta_GMT: Integer
		
	operations
		-- inicialização de um país
		inicializa(nome: String, lingua: String, moeda_oficial: String, delta_GMT: Integer)
			begin
				self.nome:= nome;
				self.lingua:= lingua;
				self.moeda_oficial:= moeda_oficial;
				self.delta_GMT:= delta_GMT
			end
			
		-- País com maior número de voos de chegada
		@static()
		paisMaisVisitado():Pais = 
			let maisVisitas: Integer = Pais.allInstances->collect(cidades.servem.voos_chegada->size)->max in
				Pais.allInstances->any(cidades.servem.voos_chegada->size = maisVisitas)
			
	constraints
	
		@HaPeloMenosUmAeroportoProximo(rationale="Existe pelo menos um aeroporto a menos de 50 Km de distância de uma cidade do país")
		inv HaPeloMenosUmAeroportoProximo:
			self.cidades.proximidade->exists(distancia<50)
			
		@NumeroContribuinteUnico(rationale="Os nacionais de um país têm números de contribuinte diferentes entre si")
		inv NumeroContribuinteUnico:
			self.nacionais->isUnique(n_contribuinte)
end

-------------------------------------------------------------------------------------------------	
abstract class Cliente
	attributes
		codigo_cliente: Integer
		nome: String
		n_contribuinte: Integer
		morada: String
		
	operations
		-- inicialização de um cliente	
		inicializa(codigo_cliente: Integer, nome: String, n_contribuinte: Integer, morada: String)
			begin
				self.codigo_cliente:= codigo_cliente;
				self.nome:= nome;
				self.n_contribuinte:= n_contribuinte;
				self.morada:= morada
			end
		
		-- criar uma nova reserva e associar-lhe um cartão de crédito, se o mesmo for indicado
		efetuarReserva(cartao_credito: CartaoCredito): Reserva
			begin
				declare
					novo_numero: Integer,
					nova_reserva: Reserva;
					
				novo_numero:= Reserva.allInstances.n_reserva->max + 1;
				if novo_numero.isUndefined() then 
						novo_numero:= 1
				end;
				nova_reserva:= new Reserva('R'+novo_numero.toString()+'_'+self.codigo_cliente.toString());
				nova_reserva.n_reserva:= novo_numero;
				
				insert (self, nova_reserva) into Cliente_Reserva;
				
				if cartao_credito.isDefined() then
					insert (cartao_credito, nova_reserva) into CartaoCredito_Reserva
				end;
				
				result:= nova_reserva
			end		
			
		-- confirmar a reserva porque foi realizado o pagamento da mesma
		confirmarReserva(reserva: Reserva)
			begin
				reserva.pagamento:= EstadoPagamento::EFETUADO
			end
		
		@ReservaEhValida(rationale="Tem de ser indicada uma reserva válida!")
		pre ReservaEhValida:
			reserva.isDefined() and reserva.cliente = self
			
		@ReservaEstaPendente(rationale="Só se pode pagar uma reserva se esta estiver pendente!")	
		pre ReservaEstaPendente:
			reserva.pagamento = EstadoPagamento::PENDENTE
		
		@ReservaEstaPaga(rationale="O pagamento da reserva foi efetuado com sucesso!")
		post ReservaEstaPaga:
			reserva.pagamento = EstadoPagamento::EFETUADO
		
		-- desistir de uma reserva, eliminando os bilhetes que lhe estão associados
		desistirReserva(reserva: Reserva, data_cancelamento: CalendarDate)
			begin
				for b in reserva.bilhetes do
					destroy b;
				end;
				destroy reserva;
			end
		
		@ParametrosInicializados(rationale="Tem de ser indicada uma reserva e uma data válidas!")
		pre ParametrosInicializados:
			reserva.isDefined() and reserva.cliente = self and data_cancelamento.isDefined()
		
		@NaoPodeEstarPaga(rationale="Só se podem apagar reservas pendentes!")
		pre NaoPodeEstarPaga:
			reserva.pagamento = EstadoPagamento::PENDENTE
		
		@NaoPodeSerTardia(rationale="Uma reserva não se pode apagar se algum dos bilhetes correspondentes for respeitante à realização de um voo que já foi efetuado à data do cancelamento!")
		pre NaoPodeSerTardia:
			not reserva.bilhetes->exists(realizacao.ocorre_em.isBefore(data_cancelamento))
		-- Implementação alternativa:	
		--	reserva.bilhetes->forAll(realizacao.ocorre_em.isAfter(data_cancelamento))

end

-------------------------------------------------------------------------------------------------	
class Individual < Cliente 
	attributes
		n_passaporte: Integer
		telefone_movel: Integer
		email: String
		genero: Genero
		
	operations
	
		-- inicialização de um cliente individual	
		inicializaIndividual(codigo_cliente: Integer, nome: String, n_contribuinte: Integer, morada: String, 
		           n_passaporte: Integer, telefone_movel: Integer, email: String, genero: Genero, pais: Pais)
			begin
				self.inicializa(codigo_cliente, nome, n_contribuinte, morada);

				self.n_passaporte:= n_passaporte;
				self.telefone_movel:= telefone_movel;
				self.email:= email;
				self.genero:= genero;

				insert (pais, self) into Pais_Individual
			end

end

-------------------------------------------------------------------------------------------------	
class Empresa < Cliente 
	attributes
		website: String
end --Empresa

-------------------------------------------------------------------------------------------------	
class Reserva
	attributes
		n_reserva: Integer
		pagamento: EstadoPagamento init = EstadoPagamento::PENDENTE
		
	operations	
			
		-- Número total de reservas pendentes (não pagas) feitas por clientes individuais	
		@static()
		totalReservasIndividuaisNaoPagas(): Integer = 
			Reserva.allInstances->select(cliente.oclIsTypeOf(Individual) and pagamento = #PENDENTE)->size

		-- Número total de reservas pendentes (não pagas) feitas por clientes individuais		
		@static()
		totalReservasIndividuaisNaoPagas2(): Integer = 
			Individual.allInstances.reservas->select(pagamento = #PENDENTE)->size
			
		-- Número total de reservas pagas que foram feitas por clientes empresariais	
		@static()
		totalReservasEmpresariaisPagas(): Integer = 
			Reserva.allInstances->select(cliente.oclIsTypeOf(Empresa) and pagamento = #EFETUADO)->size
			
		-- Número total de reservas pagas que foram feitas por clientes empresariais			
		@static()
		totalReservasEmpresariaisPagas2(): Integer = 
			Empresa.allInstances.reservas->select(pagamento = #EFETUADO)->size		
		
		-- Número de bilhetes que foram emitidos para a classe indicada. Se a reserva não foi paga devolve 0.
		bilhetesPagosPorClasse(classePretendida: Classe): Integer =
			if self.pagamento = #EFETUADO then
				bilhetes->select(classe=classePretendida)->size
			else
				0
			endif	
			
		-- emitir um bilhete para a pessoa, realização (de voo), classe e lugar indicados
		emitirBilhete(r: Realizacao, primeiro_nome: String, ultimo_nome: String, classe: Classe, lugar: Integer): Bilhete
			begin
				declare
					novo: Bilhete;
			
				novo:= new Bilhete(r.toString() + '_' + lugar.toString());
				novo.primeiro_nome := primeiro_nome;
				novo.ultimo_nome := ultimo_nome;				
				novo.lugar := lugar;
				
				insert (r, novo) into Realizacao_Bilhete;
				insert (classe, novo) into Classe_Bilhete;
				insert (self, novo) into Reserva_Bilhete;
				
				result:= novo
			end
		
		@NaoHaLugaresDuplamenteOcupados(rationale="Não se pode emitir um bilhete para um lugar que já está ocupado!")
		pre NaoHaLugaresDuplamenteOcupados:
			r.bilhetes.lugar->excludes(lugar)
			
/*			
		@ClasseExisteNoAviao(rationale="A classe para a qual o bilhete é emitido existe no avião usado na realização do voo!")
		pre ClasseExisteNoAviao:
			r.aviao.classe->includes(classe)
*/		
		
	constraints
	
		@ClientelaDiferente(rationale="Os clientes portugueses fazem menos reservas que os americanos")
		inv ClientelaDiferente:
			Pais.allInstances->any(nome='Portugal').nacionais.reservas->size <
			Pais.allInstances->any(nome='USA').nacionais.reservas->size
			
		@MesmaClasse(rationale="Os bilhetes de uma reserva relativos a realizações não canceladas têm que ser todos da mesma classe")
		inv MesmaClasse:
			self.bilhetes->select(not realizacao.cancelada)->isUnique(classe)

end

-------------------------------------------------------------------------------------------------	
class Bilhete
	attributes
		primeiro_nome: String
		ultimo_nome: String
		lugar: Integer

	operations
		-- inicialização de um bilhete
		inicializa(realizacao: Realizacao, classe: Classe, primeiro_nome: String, ultimo_nome: String, lugar: Integer)
		begin
			insert (realizacao, self) into Realizacao_Bilhete;
			insert (classe, self) into Classe_Bilhete;
			self.primeiro_nome:= primeiro_nome;
			self.ultimo_nome:= ultimo_nome;
			self.lugar:= lugar
		end	

		-- aeroporto de origem de um bilhete
		origem(): Aeroporto = realizacao.realiza_se.partida
		
		-- aeroporto de destino de um bilhete
		destino(): Aeroporto = realizacao.realiza_se.chegada

	constraints

		@CartaoValido(rationale="Um bilhete não pode ser reservado com um cartão que estará expirado na data de realização do voo correspondente")
		inv CartaoValido:
			self.reserva.isDefined and self.reserva.cartaoCredito.isDefined implies 
				self.reserva.cartaoCredito.data_expira.isAfter(self.realizacao.ocorre_em)
				
		@LugarDoBilheteValidoDentroDaClasse(rationale=
			"Um bilhete só é válido se o seu lugar estiver entre o primeiro e último número da sua classe no avião.")
		inv LugarDoBilheteValidoDentroDaClasse:
			let aviaoDoBilhete: Aviao = self.realizacao.aviao in
			let	capacidadeClasseAviao: Capacidade = Capacidade.allInstances->
					select(aviao=aviaoDoBilhete and classe= self.classe)->asOrderedSet()->first
			in
				self.lugar >= capacidadeClasseAviao.primeiro_numero and self.lugar <= capacidadeClasseAviao.ultimo_numero

end

-------------------------------------------------------------------------------------------------	
associationclass Realizacao
	between
		Voo [*] role realiza_se
		CalendarDate [*] role ocorre_em

	attributes
		cancelada: Boolean init = false
		--HG incluidos os atributos para uma data de inicio e outra de fim 
		inicio: Instant
		fim: Instant

	operations
		-- inicialização da realização de um voo
		inicializa(aviao: Aviao)
			begin
				insert (aviao, self) into Aviao_Realizacao;
			end
		
		-- serialização de uma realização de um voo
		toString(): String = 
			realiza_se.numero + '_' + ocorre_em.year.toString()+
			'_'+ocorre_em.month.toString()+'_'+ocorre_em.day.toString()	
			
	constraints
	
		@VooDeveTerOcupacaoMinima(rationale="A realização de um voo é cancelada se não estiverem ocupados pelo menos 20% dos lugares do avião respectivo")
		inv VooDeveTerOcupacaoMinima:
			bilhetes->size() / aviao.lotacao() < 0.2 implies cancelada

		@CanceladaPorOcupacaoReduzida(rationale="Uma realização é cancelada se tiver uma ocupação inferior a 30%")
		inv CanceladaPorOcupacaoReduzida:
			self.bilhetes->size() / self.aviao.capacidade.ultimo_numero->max < 0.3 implies cancelada
				
end

-------------------------------------------------------------------------------------------------	
class Aviao
	attributes
		nome: String
		modelo: String

	operations
		-- Inicialização de um avião
		inicializa(nome: String, modelo: String)
			begin
				self.nome:= nome;
				self.modelo:= modelo
			end
			
		-- Número de lugares do avião
		lotacao(): Integer = capacidade.lotacao()->sum

		-- Conjunto de cidades de onde o avião levantou voo
		cidadesDePartida(): Set(Cidade) =
			self.realizacoes->select(not cancelada).realiza_se.partida.servidas ->asSet
			
		-- Número de voos nocturnos realizados pelo avião
		-- Nota: um voo nocturno é aquele em que a hora de chegada é anterior à hora de partida
		numeroVoosNoturnos(): Integer =
			self.realizacoes->select(realiza_se.hora_chegada.hours < realiza_se.hora_partida.hours)->size
		
	constraints
		@NaoAndaAsVoltas(rationale="Não há aviões a fazer viagens circulares (aeroporto de chegada igual ao da partida)")
		inv NaoAndaAsVoltas:
			self.realizacoes->select(not cancelada).realiza_se->forAll(chegada<>partida)
			
end

-------------------------------------------------------------------------------------------------	
class Classe
	attributes
		tipo: TipoClasse
end

-------------------------------------------------------------------------------------------------	
associationclass Capacidade
	between 
		Aviao [*]
		Classe [*]
		
	attributes
		primeiro_numero: Integer
		ultimo_numero: Integer
		
	operations
		-- inicialização da capacidade do avião
		inicializa(primeiro_numero: Integer, ultimo_numero: Integer)
			begin
				self.primeiro_numero:= primeiro_numero;
				self.ultimo_numero:= ultimo_numero
			end	
	
		-- número de lugares na classe corrente deste avião
		lotacao(): Integer = ultimo_numero - primeiro_numero + 1
		
	constraints
	
		@MaisLugaresEmTuristica(rationale="Globalmente, há mais lugares em classe turística do que em classe executiva")
		inv MaisLugaresEmTuristica:
			Capacidade.allInstances->select(classe.tipo=#TURISTICA)->collect(ultimo_numero-primeiro_numero+1)->sum >
			Capacidade.allInstances->select(classe.tipo=#EXECUTIVA)->collect(ultimo_numero-primeiro_numero+1)->sum
		
end

-------------------------------------------------------------------------------------------------	
class CartaoCredito
	attributes
		numero: Integer
		data_expira: CalendarDate
		
	operations
		-- inicialização do cartão de crédito
		inicializa(cliente: Cliente, numero: Integer, data_expira: CalendarDate)
			begin
				insert (cliente, self) into Cliente_CartaoCredito;
				self.numero:= numero;
				self.data_expira:= data_expira
			end	
	
	constraints

		@NaoHaCreditoFacil(rationale="Um cartão de crédito não pode ter mais do que duas reservas com pagamento não efetuado (pendente)")
		inv NaoHaCreditoFacil:
			self.reservas->select(pagamento=#PENDENTE)->size<=2
end

-------------------------------------------------------------------------------------------------	
associationclass Proximidade
	between
		Aeroporto [*] role servem ordered
		Cidade [*] role servidas
		
	attributes
		distancia: Real
	
	constraints
	
		@DistanciaTemUmLimite(rationale="Um aeroporto só pode dizer-se que serve uma cidade a mais de 100 Km de distância se não houver outro aeroporto a uma distância menor que essa distância que sirva a mesma cidade")
		inv DistanciaTemUmLimite:
			self.distancia>100 implies servidas.proximidade->forAll(distancia>=self.distancia)

end --Proximidade


-------------------------------------------------------------------------------------------------
-- BEGIN New custom classes
-------------------------------------------------------------------------------------------------	
class Pista
	attributes 
		nomePista: String
		estado: EstadoPista
		
	operations
		inicializa(nomePista: String, estado: EstadoPista)
			begin
				self.nomePista:= nomePista;
				self.estado:= estado;
			end
end --Pista

-------------------------------------------------------------------------------------------------	
class Terminal
	attributes 
		nomeTerminal: String
		estado: EstadoTerminal
		
	operations
		inicializa(nomeTerminal: String, estado: EstadoTerminal)
			begin
				self.nomeTerminal:= nomeTerminal;
				self.estado:= estado;
			end
end --Terminal

-------------------------------------------------------------------------------------------------	
class Porta
	attributes 
		numeroPorta: Integer
		estadoPorta: EstadoPorta

	operations
		criarPorta(numeroPorta: Integer, estadoPorta: EstadoPorta, manga: Manga, autocarro: Autocarro)
			begin
				self.numeroPorta:= numeroPorta;
				self.estadoPorta:= estadoPorta;
				
				insert (self, manga) into Porta_Manga;
				insert (self, autocarro) into Porta_Autocarro;
			end	

		@PortaComManga(rationale="Se está instalada uma manga na porta de embarque, implica que não haja autocarro para transporte de passageiros.")
		pre PortaComManga:
			self.portaComManga->includes(manga)	xor self.portaComAutocarro->includes(autocarro)
			

	constraints	

		@PortaSeTemMangaNaoTemAutocarro(rationale="Se está instalada uma manga na porta de embarque, implica que não haja autocarro para transporte de passageiros.")
		inv PortaSeTemMangaNaoTemAutocarro:
			self.portaComManga.isDefined implies 
				self.portaComAutocarro->isEmpty()
				
		@PortaSeTemAutocarroNaoTemManga(rationale="Se não está instalada uma manga na porta de embarque, implica que terá que existir um autocarro para transporte de passageiros.")
		inv PortaSeTemAutocarroNaoTemManga:
			self.portaComAutocarro.isDefined implies 
				self.portaComManga->isEmpty()
end --Porta

-------------------------------------------------------------------------------------------------	
class Manga
	attributes 
		existe: Boolean
		n_manga: Integer
end --Manga

-------------------------------------------------------------------------------------------------	
class Autocarro
	attributes 
		n_autocarro: Integer
end --Autocarro

-------------------------------------------------------------------------------------------------	
class Seguranca
	attributes 
		grupo: String
end --Seguranca

-------------------------------------------------------------------------------------------------	
class Bombeiros
	attributes 
		grupo: Integer
end --Bombeiros

-------------------------------------------------------------------------------------------------	
abstract class Sinalizacao

end --Sinalizacao

-------------------------------------------------------------------------------------------------	
class PainelInfoTerminal < Sinalizacao 
	attributes
		painelInfo: EstadoTerminal
end --PainelInfoTerminal

-------------------------------------------------------------------------------------------------	
class PainelInfoPista < Sinalizacao 
	attributes
		painelInfo: EstadoPista
end --PainelInfoPista

-------------------------------------------------------------------------------------------------	
class PainelInfoPorta < Sinalizacao 
	attributes
		painelInfo: EstadoPorta
end --PainelInfoPorta

-------------------------------------------------------------------------------------------------	
class ProgramaRevisao
	attributes 
		numero: Integer
		data: CalendarDate
		hora: Instant
		execucao: EstadoRevisao init = EstadoRevisao::PROGRAMADO
		
end --ProgramaRevisao

-------------------------------------------------------------------------------------------------	
class LinhaPR
	attributes
		numero: Integer
		quantidade: Integer
end --LinhaPR

-------------------------------------------------------------------------------------------------	
class RecursoManutencao
	attributes 
		tipo: TipoRecursoManutencao
		codigo: String
		nome: String
		unidade: String
		custoUnitario: Real
end --RecursoManutencao

-------------------------------------------------------------------------------------------------
class Tripulacao
	attributes
		numeroAssistentesBordo: Integer init = 0
		
	operations
		init(numeroAssistentesBordo: Integer)
			begin
				self.numeroAssistentesBordo:= numeroAssistentesBordo;
			end
		
end --Tripulacao

-------------------------------------------------------------------------------------------------
class Catering
	attributes
		nomeEmpresa: String init = 'Nenhuma'
		
	operations
		init(nomeEmpresa: String)
			begin
				self.nomeEmpresa:= nomeEmpresa;
			end
		
end --Catering

-------------------------------------------------------------------------------------------------
class Limpeza
	attributes
		nomeEmpresa: String init = 'Nenhuma'
		
	operations
		init(nomeEmpresa: String)
			begin
				self.nomeEmpresa:= nomeEmpresa;
			end
		
end --Limpeza		

-------------------------------------------------------------------------------------------------
class EquipaOperacional
	attributes
		tripulacao: Tripulacao
		catering: Catering
		limpeza: Limpeza
		
	operations
		/************************************************************
		* 
		*************************************************************/
		init(tripulacao: Tripulacao, catering: Catering, limpeza: Limpeza, origem: Voo)
			begin
				self.tripulacao:= tripulacao;
				self.catering:= catering;
				self.limpeza:= limpeza;
				insert (self, origem) into Voo_EquipaOperacional;
			end
			
		setNumeroAssistentesBordo(novoNumero: Integer)
			begin
				self.tripulacao.numeroAssistentesBordo:= novoNumero;
			end
			
		setEmpresaCatering(novaEmpresa: String)
			begin
				self.catering.nomeEmpresa:= novaEmpresa;
			end
		
		setEmpresaLimpeza(novaEmpresa: String)
			begin
				self.limpeza.nomeEmpresa:= novaEmpresa;
			end
			
	/*statemachines
	
	 psm Usage
	 
	   states
	   
			CONSTRUCAO:initial
			
			VAZIA	[tripulacao.numeroAssistentesBordo = 0 and catering.nomeEmpresa = 'Nenhuma' and limpeza.nomeEmpresa = 'Nenhuma']
			
			SEM_TRIPULACAO	  [tripulacao.numeroAssistentesBordo = 0 and catering.nomeEmpresa <> 'Nenhuma' and limpeza.nomeEmpresa <> 'Nenhuma']

			SEM_CATERING	[tripulacao.numeroAssistentesBordo > 0 and catering.nomeEmpresa = 'Nenhuma' and limpeza.nomeEmpresa <> 'Nenhuma']
			
			SEM_LIMPEZA	  [tripulacao.numeroAssistentesBordo > 0 and catering.nomeEmpresa <> 'Nenhuma' and limpeza.nomeEmpresa = 'Nenhuma']
			
			SEM_TRIPULACAO_CATERING	  [tripulacao.numeroAssistentesBordo = 0 and catering.nomeEmpresa = 'Nenhuma' and limpeza.nomeEmpresa <> 'Nenhuma']
			
			SEM_TRIPULACAO_LIMPEZA	  [tripulacao.numeroAssistentesBordo = 0 and catering.nomeEmpresa <> 'Nenhuma' and limpeza.nomeEmpresa = 'Nenhuma']
			
			SEM_CATERING_LIMPEZA	[tripulacao.numeroAssistentesBordo > 0 and catering.nomeEmpresa = 'Nenhuma' and limpeza.nomeEmpresa = 'Nenhuma']
			
			EM_ATUACAO	  [tripulacao.numeroAssistentesBordo > 0 and catering.nomeEmpresa <> 'Nenhuma' and limpeza.nomeEmpresa <> 'Nenhuma'] 
			
	   transitions
	   
			CONSTRUCAO -> VAZIA  { create }
			VAZIA -> SEM_TRIPULACAO_CATERING { setEmpresaLimpeza() }
			VAZIA -> SEM_TRIPULACAO_LIMPEZA { setEmpresaCatering() }
			VAZIA -> SEM_CATERING_LIMPEZA { setNumeroAssistentesBordo() }
			
	 end -- of psm Usage*/
	 
end -- of class EquipaOperacional		

-------------------------------------------------------------------------------------------------
-- END New custom classes
-------------------------------------------------------------------------------------------------	

--------------------------------------------------------------
-- Initial Associations
--------------------------------------------------------------
association Aeroporto_VoosPartida between 
	Aeroporto [1] role partida
	Voo [*] role voos_partida ordered
end

association Aeroporto_VoosChegada between 
	Aeroporto [1] role chegada
	Voo [*] role voos_chegada ordered
end

composition Pais_Cidade between 
	Pais [1]
	Cidade [*] role cidades
end

association Pais_Individual between 
	Pais [*] role nacionalidade
	Individual [*] role nacionais
end

association Cliente_Reserva between 
	Cliente [1]
	Reserva [*] role reservas
end

association Cliente_CartaoCredito between 
	Cliente [1] role possuidor
	CartaoCredito [*] role cartoes
end

aggregation Reserva_Bilhete between 
	Reserva [0..1]
	Bilhete [1..*] role bilhetes ordered
end

association CartaoCredito_Reserva between 
	CartaoCredito [0..1]
	Reserva [*] role reservas ordered
end

association Realizacao_Bilhete between 
	Realizacao [1]
	Bilhete [*] role bilhetes
end

association Classe_Bilhete between 
	Classe [1]
	Bilhete [*] role bilhetes
end

association Aviao_Realizacao between 
	Aviao [1]
	Realizacao [*] role realizacoes ordered
end

association Pista_Realizacao
	between
		Pista [1] role pistaRealizacao
		Realizacao [*] role realizacaoPista
end


--------------------------------------------------------------
-- BEGIN New custom Associations
--------------------------------------------------------------
composition Aeroporto_Pista between 
	Aeroporto [1] role aeroportoPistas
	Pista [1..*] role pistas
end

composition Aeroporto_Terminal between 
	Aeroporto [1] role aeroportoTerminais
	Terminal [1..*] role terminais
end

composition Terminal_Porta between 
	Terminal [1] role porta
	Porta [1..*] role portas
end

association Voo_EquipaOperacional between
	EquipaOperacional [1] role ocorre_com
	Voo [*] role realiza_se
end	

association Pista_PainelInfoPista between 
	Pista [1]
	PainelInfoPista [*] role infoPista
end

association Terminal_InfoTerminal between 
	Terminal [1]
	PainelInfoTerminal [*] role infoTerminal
end

association Porta_PainelInfoPorta between 
	Porta [1]
	PainelInfoPorta [*] role infoPorta
end

composition Programa_Linha between 
	ProgramaRevisao [1] role programa
	LinhaPR [*] role linhas
end

association Linha_Recurso between 
	RecursoManutencao [1] role recurso
	LinhaPR [*] role linha
end

association Programa_Aviao between 
	Aviao [1] role aviao
	ProgramaRevisao [*] role programa
end

association Porta_Manga between 
	Porta [1]
	Manga [0..1] role portaComManga
end

association Porta_Autocarro between 
	Porta [1]
	Autocarro [0..1] role portaComAutocarro
end

--------------------------------------------------------------
-- END New custom Associations
--------------------------------------------------------------


--------------------------------------------------------------
-- Library types
--------------------------------------------------------------

class CalendarDate

	attributes
		day: Integer
		month: Integer
		year: Integer

	operations
		-- calendar date initialization
		init(day: Integer, month: Integer, year: Integer)
			begin
				self.day:= day;
				self.month:= month;
				self.year:= year
			end
			
		-- calendar date initialization based on a string with the format yyyy-mm-dd
		initS(date: String)
			begin
				self.year:= date.substring(1,4).toInteger();
				self.month:= date.substring(6,7).toInteger();
				self.day:= date.substring(9,10).toInteger()
			end	
		
		-- returns a calendar date that matches a string with the format yyyy-mm-dd
		@static()
		stringToDate(date: String): CalendarDate
			begin
				declare temp: CalendarDate;
				
				temp:= new CalendarDate();
				temp.initS(date);
				result:= CalendarDate.allInstances-> any(cd | cd.isEqual(temp));
				if result.isUndefined() then
					result:= new CalendarDate('D'+temp.year.toString()+temp.month.toString()+temp.day.toString());
					result.initS(date)
				end
			end
			
		-- returns true if the current date is before the one in the argument
		isBefore(t: CalendarDate):Boolean = 
			if self.year = t.year then
				if self.month = t.month then
				self.day < t.day
				 else
				self.month < t.month
				 endif
			else 
				self.year < t.year
			endif

		-- returns true if the current date is after the one in the argument
		isAfter(t: CalendarDate):Boolean =
			if self.year = t.year then
				if self.month = t.month then
					self.day > t.day
				 else
					self.month > t.month
				endif
			else 
				self.year > t.year
			endif

		-- returns true if the current object has the same state as the one in the argument
		isEqual(t: CalendarDate):Boolean =
			self.year  = t.year and
			self.month = t.month and
			self.day   = t.day

		-- returns the number of full elapsed years since the date in the argument
		yearsSince(t: CalendarDate):Integer =
			if self.month < t.month or
			   self.month = t.month and self.day < t.day then
					self.year - t.year -1
			else
				self.year - t.year
			endif

		-- auxiliary function for checking if x is divisible by y
		@static()	
		isDivisible(x: Integer, y: Integer): Boolean = x div y * y = x
		
		-- returns true if the current year is a leap year
		isLeap(): Boolean =
			if isDivisible(self.year, 400) or isDivisible(self.year, 4) then
				true
			else
				if isDivisible(self.year, 100) then
					 false
				else
					if isDivisible(self.year, 4) then
						true
					else
						false
					endif
				endif
			endif
			
		-- returns true if the current object contains a valid date		
		valid(): Boolean =
			self.month>=1 and self.month<=12 and self.day>=1 and
			if self.isLeap() then
				self.day<=Sequence{31,29,31,30,31,30,31,31,30,31,30,31}->at(self.month)
			else 
				self.day<=Sequence{31,28,31,30,31,30,31,31,30,31,30,31}->at(self.month)
			endif
			
		-- format: yyyy-mm-dd
		toString(): String = year.toString()+'-'+month.toString()+'-'+day.toString()
		
end

-------------------------------------------------------------------------------------------------	
class Instant

	attributes	
		hours: Integer
		minutes: Integer
		seconds: Integer
		
	operations
		-- calendar date initialization
		init(hours: Integer, minutes: Integer, seconds: Integer)
			begin
				self.hours:= hours;
				self.minutes:= minutes;
				self.seconds:= seconds
			end		
			
		-- returns true if the current object has the same state as the one in the argument
		isEqual(i: Instant):Boolean =
			self.hours   = i.hours and
			self.minutes = i.minutes and
			self.seconds = i.seconds
			
		-- format: hh:mm:ss
		toString(): String = hours.toString()+':'+minutes.toString()+':'+seconds.toString()
			
end

-------------------------------------------------------------------------------------------------
class Random

	attributes
		-- Linear congruential values for x(i+1) = (a * x(i) + b) % m.
		a: Integer
		b: Integer
		m: Integer
		x: Integer

	operations
		-- initializes this pseudo random number generator with the given seed	
		init(seed: Integer)
			begin
				self.a:= 25173;
				self.b:= 13849;
				self.m:= 32768;
				self.x:= seed
			end

		-- pseudo random real number in the [0, 1] interval
		nextReal(): Real
			begin
				-- Calculate next value in sequence.
				self.x := (self.a * self.x + self.b).mod(self.m);

			-- Return its 0-to-1 value
				result:= self.x / self.m
			end

		-- pseudo random integer number in the [initial, last] interval;
		-- the last value should be greater than the initial one
		nextInteger(initial: Integer, last: Integer): Integer
			begin
				declare 
					next: Real;
					
				next:= self.nextReal();		
				result:= initial + (next * (last - initial)).round()
			end
			
		pre LastGreaterThanInitial: last > initial
			
end
